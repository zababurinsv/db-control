import require$$0 from '../xtend/index.js';
import require$$1 from '../minimatch/minimatch.js';
import require$$2 from '../abstract-error';
import 'inherits-ex';
import require$$5 from 'util-ex/lib/is/type/array';
import require$$6 from 'util-ex/lib/is/type/string';
import require$$7 from 'util-ex/lib/is/type/function';
import require$$8 from 'util-ex/lib/is/type/buffer';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var abstractIterator$1 = {exports: {}};

var abstractIterator = {exports: {}};

var consts = {exports: {}};

var hasRequiredConsts;

function requireConsts () {
	if (hasRequiredConsts) return consts.exports;
	hasRequiredConsts = 1;
	// Generated by CoffeeScript 1.12.7
	(function() {
	  var consts$1;

	  consts$1 = {
	    FILTER_INCLUDED: 0,
	    FILTER_EXCLUDED: 1,
	    FILTER_STOPPED: -1
	  };

	  consts.exports = consts$1;

	}).call(commonjsGlobal);
	return consts.exports;
}

// Generated by CoffeeScript 1.12.7
(function() {
  var AlreadyEndError, AlreadyRunError, Errors, FILTER_EXCLUDED, FILTER_STOPPED, InvalidArgumentError, NotImplementedError, consts, createError, isArray, isBuffer, isFunction, isString, minimatch, xtend;

  xtend = require$$0;

  minimatch = require$$1;

  Errors = require$$2;

  consts = requireConsts();

  isArray = require$$5;

  isString = require$$6;

  isFunction = require$$7;

  isBuffer = require$$8;

  NotImplementedError = Errors.NotImplementedError;

  InvalidArgumentError = Errors.InvalidArgumentError;

  createError = Errors.createError;

  AlreadyEndError = createError("AlreadyEnd", 0x53);

  AlreadyRunError = createError("AlreadyRun", 0x54);

  FILTER_EXCLUDED = consts.FILTER_EXCLUDED;

  FILTER_STOPPED = consts.FILTER_STOPPED;

  Errors.AlreadyEndError = AlreadyEndError;

  Errors.AlreadyRunError = AlreadyRunError;

  abstractIterator.exports = (function() {
    AbstractIterator.AlreadyEndError = AlreadyEndError;

    AbstractIterator.AlreadyRunError = AlreadyRunError;

    function AbstractIterator(db, options) {
      var isKeysIterator;
      this.db = db;
      this._ended = false;
      this._nexting = false;
      this.options = this.initOptions(options);
      options = this.options;
      isKeysIterator = options && isArray(options.range);
      if (isKeysIterator) {
        this._resultOfKeys = options.range;
        this._indexOfKeys = -1;
      }
      return !isKeysIterator;
    }

    AbstractIterator.prototype.initOptions = function(options) {
      var end, endOp, range, skipEnd, skipStart, start, startOp;
      options = xtend(options);
      options.reverse = !!options.reverse;
      range = options.range;
      if (isString(range)) {
        range = range.trim();
        if (range.length >= 2) {
          skipStart = !options.reverse ? range[0] === "(" : range[range.length - 1] === ")";
          skipEnd = !options.reverse ? range[range.length - 1] === ")" : range[0] === "(";
          range = range.substring(1, range.length - 1);
          range = range.split(",").map(function(item) {
            item = item.trim();
            if (item === "") {
              item = null;
            }
            return item;
          });
          if (!options.reverse) {
            start = range[0], end = range[1];
            startOp = 'gt';
            endOp = 'lt';
          } else {
            end = range[0], start = range[1];
            startOp = 'lt';
            endOp = 'gt';
          }
          if (!skipStart) {
            startOp = startOp + 'e';
          }
          if (!skipEnd) {
            endOp = endOp + 'e';
          }
          options[startOp] = start;
          options[endOp] = end;
        }
      }
      options.keys = options.keys !== false;
      options.values = options.values !== false;
      options.limit = ("limit" in options ? options.limit : -1);
      options.keyAsBuffer = options.keyAsBuffer === true;
      options.valueAsBuffer = options.valueAsBuffer === true;
      if (options.next) {
        if (options.reverse !== true) {
          options.gt = options.next;
          options.gte = options.next;
        } else {
          options.lt = options.next;
          options.lte = options.next;
        }
      }
      ["start", "end", "gt", "gte", "lt", "lte"].forEach(function(o) {
        if (options[o] && isBuffer(options[o]) && options[o].length === 0) {
          return delete options[o];
        }
      });
      if (options.keys && isString(options.match) && options.match.length > 0) {
        this.match = function(item) {
          return minimatch(item[0], options.match);
        };
      }
      if (isFunction(options.filter)) {
        this.filter = function(item) {
          return options.filter(item[0], item[1]);
        };
      }
      this.encodeOptions(options);
      return options;
    };

    AbstractIterator.prototype.encodeOptions = function(options) {};

    AbstractIterator.prototype.decodeResult = function(result) {};

    AbstractIterator.prototype._next = function(callback) {
      var self;
      self = this;
      if (this._nextSync) {
        return setImmediate(function() {
          var e, result;
          try {
            result = self._nextSync();
            self._nexting = false;
          } catch (error) {
            e = error;
            self._nexting = false;
            callback(e);
            return;
          }
          if (result) {
            callback(null, result[0], result[1]);
          } else {
            callback();
          }
        });
      } else {
        return setImmediate(function() {
          self._nexting = false;
          callback();
        });
      }
    };

    AbstractIterator.prototype._end = function(callback) {
      var self;
      self = this;
      if (this._endSync) {
        return setImmediate(function() {
          var e, result;
          try {
            result = self._endSync();
            return callback(null, result);
          } catch (error) {
            e = error;
            return callback(e);
          }
        });
      } else {
        return setImmediate(function() {
          return callback();
        });
      }
    };

    AbstractIterator.prototype.nextKeysSync = function() {
      var result;
      this._nexting = true;
      if (this._indexOfKeys === -1) {
        this._resultOfKeys = this.db._mGetSync(this._resultOfKeys, this.options);
        this._indexOfKeys++;
      }
      result = this._indexOfKeys >= 0 && this._indexOfKeys < this._resultOfKeys.length;
      if (result) {
        result = this._resultOfKeys.slice(this._indexOfKeys, this._indexOfKeys += 2);
        this.decodeResult(result);
        result = {
          key: result[0],
          value: result[1]
        };
      }
      this._nexting = false;
      return result;
    };

    AbstractIterator.prototype.nextSync = function() {
      var result;
      if (this._ended) {
        throw new AlreadyEndError("cannot call next() after end()");
      }
      if (this._nexting) {
        throw new AlreadyRunError("cannot call next() before previous next() has completed");
      }
      if (this._filterStopped) {
        return false;
      }
      if (this._indexOfKeys != null) {
        return this.nextKeysSync();
      } else if (this._nextSync) {
        this._nexting = true;
        result = this._nextSync();
        if (result !== false) {
          this.decodeResult(result);
          if (this.filter) {
            switch (this.filter(result)) {
              case FILTER_EXCLUDED:
                this._nexting = false;
                this.nextSync();
                return;
              case FILTER_STOPPED:
                this._filterStopped = true;
            }
          }
          if (this.match && !this.match(result)) {
            this._nexting = false;
            this.nextSync();
            return;
          }
          result = {
            key: result[0],
            value: result[1]
          };
          this.last = result[0];
        }
        this._nexting = false;
        return result;
      } else {
        throw new NotImplementedError();
      }
    };

    AbstractIterator.prototype._endKeys = function() {
      delete this._resultOfKeys;
      return this._indexOfKeys = -2;
    };

    AbstractIterator.prototype.freeSync = function() {
      if (this._indexOfKeys != null) {
        this._endKeys();
      }
      if (this._endSync) {
        this._ended = true;
        return this._endSync();
      } else {
        throw new NotImplementedError();
      }
    };

    AbstractIterator.prototype.endSync = AbstractIterator.prototype.freeSync;

    AbstractIterator.prototype.nextKeys = function(callback) {
      var result, self;
      this._nexting = true;
      if (this._indexOfKeys === -1) {
        self = this;
        this.db._mGet(this._resultOfKeys, this.options, function(err, arr) {
          self._nexting = false;
          if (err) {
            return callback(err);
          }
          self._resultOfKeys = arr;
          self._indexOfKeys++;
          return self.next(callback);
        });
        return this;
      } else if (this._indexOfKeys >= 0 && this._indexOfKeys < this._resultOfKeys.length) {
        result = this._resultOfKeys.slice(this._indexOfKeys, this._indexOfKeys += 2);
        this.decodeResult(result);
        this._nexting = false;
      } else {
        result = false;
      }
      this._nexting = false;
      if (result === false) {
        callback();
      } else {
        callback(void 0, result[0], result[1]);
      }
      return this;
    };

    AbstractIterator.prototype.next = function(callback) {
      var self;
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("next() requires a callback argument");
      }
      if (this._ended) {
        return callback(new AlreadyEndError("cannot call next() after end()"));
      }
      if (this._nexting) {
        return callback(new AlreadyRunError("cannot call next() before previous next() has completed"));
      }
      if (this._filterStopped) {
        return callback();
      }
      if (this._indexOfKeys != null) {
        this.nextKeys(callback);
      } else {
        this._nexting = true;
        self = this;
        this._next(function(err, key, value) {
          var result;
          self._nexting = false;
          if (!err && ((key != null) || (value != null))) {
            result = [key, value];
            self.decodeResult(result);
            if (self.filter) {
              switch (self.filter(result)) {
                case FILTER_EXCLUDED:
                  self.next(callback);
                  return;
                case FILTER_STOPPED:
                  self._filterStopped = true;
              }
            }
            if (self.match && !self.match(result)) {
              self.next(callback);
              return;
            }
            key = result[0];
            value = result[1];
            self.last = result[0];
          }
          return callback.apply(null, arguments);
        });
      }
      return this;
    };

    AbstractIterator.prototype.free = function(callback) {
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("end() requires a callback argument");
      }
      if (this._ended) {
        return callback(new AlreadyEndError("end() already called on iterator"));
      }
      if (this._indexOfKeys != null) {
        this._endKeys();
      }
      this._ended = true;
      return this._end(callback);
    };

    AbstractIterator.prototype.end = AbstractIterator.prototype.free;

    return AbstractIterator;

  })();

}).call(commonjsGlobal);

(function (module) {
	module.exports   = abstractIterator.exports;
} (abstractIterator$1));

var index = /*@__PURE__*/getDefaultExportFromCjs(abstractIterator$1.exports);

export { index as default };
