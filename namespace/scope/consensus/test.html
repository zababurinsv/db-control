<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Consensus</title>

<!--    <script type="text/javascript" src="/node/tera/Source/jinn/extlib/sha3.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/extlib/RBTree.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/extlib/terabuf.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/lib/cache-block.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/lib/time-sync.js"></script>-->
<!--    <script type="text/javascript" src="./assets/model-lib.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/index.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-log.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-stat.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/db/jinn-db-base.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/db/jinn-db-row.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/db/jinn-db-item.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/db/jinn-db-chain.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/db/cache-db.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/db/jinn-db-cache-body.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/db/jinn-db-cache-block.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-block-db.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-connect.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-connect-item.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-connect-handshake.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-connect-speed.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-connect-score.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-connect-addr.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-connect-hot.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-session.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-ticket.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-tx.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-tx-err.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-tx-priority.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-tx-control.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-tx-resend.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-block.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-block-mining.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-consensus-chain.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-consensus.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-consensus-boost.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-net-cache.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-startup-loader.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-timing.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-time-sync.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-filter.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-net.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-sharding.js"></script>-->
<!--    <script type="text/javascript" src="./assets/model-network.js"></script>-->
<!--    <script type="text/javascript" src="./assets/model-node.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/jinn/src/jinn-serialize.js"></script>-->
<!--    <script type="text/javascript" src="./assets/model-environment.js"></script>-->
<!--    <script type="text/javascript" src="/node/tera/Source/HTML/JS/diagram.js"></script>-->
</head>
<body>
<noscript>You need to enable JavaScript to run this app.</noscript>
<div id="root"></div>
<script type="module">
    import AppClass from '/modules/consensus/index.js'
    import init from '/modules/blockchain/init.mjs';
    import environment from './assets/model-environment.mjs';
    import jinn from '/modules/blockchain/jinn/src/index.mjs';
    import jinnDbBase from '/modules/blockchain/jinn/src/db/jinn-db-base.mjs';
    import library from '/modules/blockchain/core/library.mjs'
    import node from './assets/model-node.mjs'
    import jinnConnectAddr from '/modules/blockchain/jinn/src/jinn-connect-addr.mjs'
    (async () => {
        let global = {}
        global = await init(global)
        global = await library(global)
        global = await jinnDbBase(global)
        global = await jinn(global)
        global = await node(global)
        global = await environment(global)
        global = await jinnConnectAddr(global)
        let MODEL;
        // var glDeltaScreenX = 0;
        // var glDeltaScreenY = 0;
        function InitNodes() {
            MODEL = global.CreateModel(5,1);
        }

        InitNodes()
        MODEL.AddNode(5);

        let app = new AppClass({
            "section1": {
                //have inapp default values: centralized, pow, pos, dpow, dpos, details below.
                "extends": "dpow",//can extend section, for example we can create section2 and extends section1 params.
            },
            "section2": {//extending can be nested
                "extends": "section1"
            },
            "genesis": {//requied!, defile first, genesis block here.
                "id": 'genesis',
                "prev": -1,
                "bits": 1,
                "time": 0,
                "nonce": 0,
            },
            //below we create sections for each consensus algorithm and show required params for each:
            "centralized": {
                //public key of centralized node, only for centralized consensus.
                "mainNode": "0x0"
            },
            "pow": {
                "premine": 24,//how much blocks we need skip, before recalc target start works
                "blockcount": 12, ///number of blocks in target calculation
                "blocktime": 300, //time of one block in seconds
                "maxtarget": 1, //min difficulty value, we search hash value (uint128) smaller than: hash*target < 2^250
                "excludeFirst": 1, //dont use this numbers blocks in calculation of new target
                "diffWindow": 120, //window of data, used for target
                "diffCut": 6
            },
            'pos': {
                'extends': 'pow',//extending config params from pow section
                //this value is used only for pos/dpos consensus algo, defile how much percent we can decrease in target for stake value, for example: newtarget = (1-shareStake)*target
                'shareStake': 0.1,//max share of stake value that we can decrease from target
            },
            'dpow': {
                'extends': 'pow',
                'delegateMode': true,//new block can emit only public keys from this array or from method data::isDelegateMessage
                //used only for dpow,dpos. We can write static delegates who can send new blocks (check public key of coinbase tx of block, yes, coinbase tx must be signed like another)
                "delegates": ['0x0']//for example we have 1 static delegate in config 0x0, and 1 dynamic 0x2, in data::isDelegateMessage
            },
            'dpos': {
                'extends': 'pos',
                'delegateMode': true,
                'delegates': []
            },
        });

        app.on("debug", (data) => {//debug event
            console.log("[" + new Date().toLocaleTimeString() + "]", "< " + data.level + " >", data.module, data.text);
        });

//here you can redefine data class
        app.defineDataClass(((app) => {

            class PosData extends app.DATA {//must extends from app.DATA class, and redefine it here
                //for each fields [id, public key of sender (for pos/dpos), previd (prev block id), bits, time, ]
                //for each method we can redefine get{Field}FieldName
                static getPrevIdFieldName() {
                    return 'prev';
                }
                //redefine check for valididy of block
                isValid() {
                    return super.isValid();
                }
                //stake value for pos\dpos for public key
                getStakeValue(height) {
                    let key = this.getKey();
                    //get amount of coins on balance of key
                    return Stakes[key]
                }
                //get public key from block (sign coinbase)
                getKey() {
                    return this.data.tx[0].key;
                }
                //check that message is from delegate. By public key
                isDelegateMessage() {
                    let res = super.isDelegateMessage();
                    //in real app: check balance or another info by public key of data, in our example:
                    if (this.getKey() == '0x2')
                        return true;
                    return res;
                }

                //allMethods:
                //static IsDataMessage(message) - is message data, check
                //static getIdFieldName() - name of "id" field
                //static getPrevIdFieldName() - "prevId" name field
                //static getTimeFieldName() - name of field "time"
                //static getBitsFieldName() - "bits" name field
                //getId() - get id value
                //getPrevId() //get prevId value
                //getBits() - get bits value
                //getKey() - get public key of block (used for POS consensus only - need sign coinbase block)
                //getTime() - get time valye
                //isValid() check that data is valid, must be reimplemented
                //getStakeValue(height) - get stake value for this.getKey(), used only for POS consensys
                //isDelegateMessage() - check data for delegate owner, used only in delegateMode
            }

            return PosData;
        })(app));

//redefine Peer class
        app.definePeerClass(((app) => {

            class PosPeer extends app.PEER {
                send(peerId, msg) {
                    console.log("send from peer", this.getId(), " to peer ", peerId, msg);
                }
                //methods:
                //getId - id of peer
                //relay(msg) - send for all connected nodes
                //newMessage - recive message method, invoke when new message recived
                //close - close implementation, invoke on error,close
                //error - invoke on error

            }

            return PosPeer;
        })(app));

        app.defineConsensusClass(((app) => {
            //default consensuses:
            //app.CONSENSUS.Centralized
            //app.CONSENSUS.ProofOfWorkConsensus
            //app.CONSENSUS.ProofOfStakeConsensus
            //app.CONSENSUS.DelegatedProofOfWorkConsensus
            //app.CONSENSUS.DelegatedProofOfStakeConsensus
            class PosConsensus extends app.CONSENSUS.ProofOfStakeConsensus {
                constructor() {
                    //first param - name of your consensus algorithm, second param - section on config, used for this consensus
                    super("Example PoS test consensus", "exampledpos")//must append examplepos section in config before start
                }

                //all methods (must be implemented for your consensus):
                //applyData(peer, data) - add Data to blockchain
                //isPeerCanSendData(peer) - check: can peer send data
                //isDataMatch(data, peer) - check: can add this data to consensus
                //isDelegateMode() - true if we have delegatePoS/delegatePoW consensus
                //checkHash(hash, target) - check hash for this target
                //getStakeToTargetTransform(publicKey, stake, target) - transform stakeValue of publicKey for target (used for decrease target for investors in POS)

                getStakeToTargetTransform(publicKey, stake, target) {

                    let share = stake / allcoins;//[0;1]
                    let shareAll = 0.3 * share;//max share - 30%
                    return target * (1 - shareAll);//min: 0.7 * target, max: 1 * target

                }
                isDataMatch(data, peer) {
                    if (this.getConfig('delegateMode')) {
                        return this.getConfig('delegates').indexOf(data.getKey()) >= 0 || data.isDelegateMessage();
                    }
                }
            }

            return PosConsensus;
        })(app));

        app.definePeerManagerClass(((app) => {
            class PeerManager2 extends app.PEERMANAGER {
                constructor() {
                    super();
                    this.list = {};
                    this.debug("debug", "inited");
                }

                getPeersList() {
                    return this.list;
                }

                addPeers(peers) {
                    for (let i in peers) {
                        this.list[peers[i].getId()] = peers[i];
                    }
                }

                addPeer(peer) {
                    this.list[peer.IDStr] = peer;
                }

                removePeerById(peerId) {
                    delete this.list[peerId];
                }

                removePeer(peer) {
                    this.removePeerById(peer.getId());
                }
            }

            return PeerManager2;
        })(app));


        app.start('pos');

        let manager = new  app.PEERMANAGER()
        for (let node of MODEL.NetNodeArr) {
            manager.addPeer(node)
            // console.log('!!!!!!!!!!!!!!!!!!!! === global ===', node.IDStr, MODEL.NetNodeMap[node.IDStr])
        }

        setTimeout(function run() {

            console.log('===== manager =====', manager)
           setTimeout(run, 1000);
        }, 1000);

    })()
</script>
</body>
</html>
