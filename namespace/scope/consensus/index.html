<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Consensus</title>
</head>
<body>
<noscript>You need to enable JavaScript to run this app.</noscript>
<div id="root"></div>
<script type="module">
    import AppClass from '/modules/consensus/index.js'
    import init from '/modules/blockchain/init.mjs';
    import environment from './assets/model-environment.mjs';
    import jinn from '/modules/blockchain/jinn/src/index.mjs';
    import jinnDbBase from '/modules/blockchain/jinn/src/db/jinn-db-base.mjs';
    import library from '/modules/blockchain/core/library.mjs';
    import node from './assets/model-node.mjs';
    import jinnConnectAddr from '/modules/blockchain/jinn/src/jinn-connect-addr.mjs';


    (async () => {
        let global = {};
        global = await init(global)
        global = await library(global)
        global = await jinnDbBase(global)
        global = await jinn(global)
        global = await node(global)
        let modules = {}
        modules.block = {}
        modules.block.Engine = {}
        console.log('global.JINN_MODULES====', global.JINN_MODULES)
        modules.block.Block = (global.JINN_MODULES.filter(item => item.Name === 'Block'))[0]
        modules.block.Mining = (global.JINN_MODULES.filter(item => item.Name === 'Mining'))[0]
        modules.block.Tx = (global.JINN_MODULES.filter(item => item.Name === 'Tx'))[0]
        modules.block.TxPriority = (global.JINN_MODULES.filter(item => item.Name === 'TxPriority'))[0]
        modules.block.TxControl = (global.JINN_MODULES.filter(item => item.Name === 'TxControl'))[0]



        modules.block.Engine.TickNum = 0
        modules.block.class = modules.block.Block.InitClass(modules.block.Engine)
        modules.block.class = modules.block.Mining.InitClass(modules.block.Engine)
        modules.block.class = modules.block.Tx.InitClass(modules.block.Engine)
        modules.block.class = modules.block.TxPriority.InitClass(modules.block.Engine)
        modules.block.class = modules.block.TxControl.InitClass(modules.block.Engine)
        let gen = modules.block.Engine.GetGenesisBlock(0)

        global = await environment(global)
        global = await jinnConnectAddr(global)
        let MODEL;
        function InitNodes() {
            MODEL = global.CreateModel(5,1);
        }
        InitNodes()
        MODEL.AddNode(5);


        let app = new AppClass({
            "section1": {
                "extends": "dpow",
            },
            "section2": {
                "extends": "section1"
            },
            "genesis": gen,
            // "genesis": {
            //     "DataHash": 'genesis',
            //     "PrevSumHash": -1, //"prev": -1,
            //     "bits": 1,
            //     "time": 0,
            //     "nonce": 0,
            // },
            "centralized": {
                "mainNode": "0x0"
            },
            "pow": {
                "premine": 24,
                "blockcount": 12, ///number of blocks in target calculation
                "blocktime": 300, //time of one block in seconds
                "maxtarget": 1, //min difficulty value, we search hash value (uint128) smaller than: hash*target < 2^250
                "excludeFirst": 1, //dont use this numbers blocks in calculation of new target
                "diffWindow": 120, //window of data, used for target
                "diffCut": 6
            },
            'pos': {
                'extends': 'pow',//extending config params from pow section
                //this value is used only for pos/dpos consensus algo, defile how much percent we can decrease in target for stake value, for example: newtarget = (1-shareStake)*target
                'shareStake': 0.1,//max share of stake value that we can decrease from target
            },
            'dpow': {
                'extends': 'pow',
                'delegateMode': true,//new block can emit only public keys from this array or from method data::isDelegateMessage
                //used only for dpow,dpos. We can write static delegates who can send new blocks (check public key of coinbase tx of block, yes, coinbase tx must be signed like another)
                "delegates": ['0x0']//for example we have 1 static delegate in config 0x0, and 1 dynamic 0x2, in data::isDelegateMessage
            },
            'dpos': {
                'extends': 'pos',
                'delegateMode': true,
                'delegates': []
            },
        });

        app.on("debug", (data) => {//debug event
            console.log("[" + new Date().toLocaleTimeString() + "]", "< " + data.level + " >", data.module, data.text);
        });

        app.defineDataManagerClass(((app) => {

            class DataManager2 extends app.DATAMANAGER {
                constructor() {
                 super()
                    //methods:
                    //getDataList() - get all blocks
                    //_addDataToBlockChain(data) - add Data to blockchain without any checking (startup init from db)
                    //addData(data) - add to blockchain with checks for data-valid (from network)
                    //getData(id) - get data by id
                    //getDataFromHeight(h) - get data from height
                    //getDataHeight(dataId) - return height by id
                    //getHeight() - get blockchain height
                    //getDataSlice(a, b) - get slice of blockchain from a to b, if b is not exist - b = 0, top block on top in list[0]
                    //replaceDataById(dataId, newData) - replace blocks with id with newData
                    //replaceData(oldData, newData) - replace oldBlock to newBlock
                    //getTopInfo() - get top block hash and height
                    //isDataLinked(data) - check data for linking to blockchain (data.previd exist or genesis)
                    //getGenesis() - return genesis section from config
                }

                addData(data) {
                    if (data.isValid()) {
                        return this._addDataToBlockChain(data, app.consensus.config.ignorePrevChilds);
                    } else
                        throw new Error('Invalid data');
                }

            }

            return DataManager2;
        })(app));

        app.defineDataClass(((app) => {

            class emperaData extends app.DATA {//must extends from app.DATA class, and redefine it here

                isValid() {
                    if (this.getId()) {
                        return true;
                    }
                    return false;
                }

                getId() {
                    let key = app.DATA.getIdFieldName()
                    return this.data[app.DATA.getIdFieldName()];
                }

                getPrevId() {
                    return this.data[app.DATA.getPrevIdFieldName()];
                }

                getGenesis() {

                    return new app.DATA(app.config['genesis']);
                }

                static getPrevIdFieldName() {
                    return 'PrevSumHash';
                }

                static getIdFieldName() {
                    return 'SumHash';
                }

            }

            return emperaData;
        })(app));

        app.start('pow');
        // let manager = { }
        // manager.peer = new  app.PEERMANAGER()
        // manager.data = new app.DATAMANAGER()

        // let consensus = new app.CONSENSUS.ProofOfStakeConsensus()

        // let Alice = new app.PEER()
        // let Bob = new app.PEER()
        // let Cooper = new app.PEER()

        // let data = {}
        // data.alice = new app.DATA()
        // data.bob = new app.DATA()
        // data.cooper = new app.DATA()

        // for (let node of MODEL.NetNodeArr) {
        //     app.peerManager.addPeer(node)
        // }
        //

        let {data: Genesis} = app.dataManager.getGenesis()
        // console.log('genesis', Genesis)
        // console.log('getHeight', app.dataManager.getHeight())
        // console.log('getTopInfo', app.dataManager.getTopInfo())

        const runtime = (app) => {
            return new Promise((resolve,reject) => {
                let count = 0
                let block = {}
                let timerId = setTimeout(function tick() {
                    if(count === 0) {
                        block = new app.DATA(Genesis)
                        // block = new app.DATA(Genesis)
                    } else {
                        // const {DataHash : prev} = app.dataManager.getTopInfo()
                        const newBlock = modules.block.Engine.GetNewBlock(block.data)
                        block = new app.DATA(modules.block.Engine.GetNewBlock(block.data))

                        // block = new app.DATA({
                        //     DataHash: count, //id
                        //     version: 1,
                        //     PrevSumHash: prev,
                        //     time: Date.now(),
                        //     nonce: 2,
                        //     bits: 123123123,
                        // })
                    };
                    if(count < 10) {
                        count = count + 1
                        app.dataManager.addData(block)
                        timerId = setTimeout(tick, 500)
                    } else {
                        clearInterval(timerId)
                        resolve(app)
                    }
                    // (count < 10)
                    //     ? (count = count + 1, app.dataManager.addData(block), timerId = setTimeout(tick, 500))
                    //     : (clearInterval(timerId), resolve(app))
                }, 500);
            })
        }

        app = await runtime(app)

        console.log('===',app)
        debugger
    })()
</script>
</body>
</html>
